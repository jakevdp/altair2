import collections
import inspect
import json
import keyword
import re
from functools import wraps

import jsonschema

from .utils import hash_schema, SchemaInfo, resolve_references
from .visitors import FromDict


class UndefinedType(object):
    """A singleton object for marking undefined attributes"""
    __instance = None
    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.__instance, cls):
            cls.__instance = object.__new__(cls, *args, **kwargs)
        return cls.__instance
    def __repr__(self):
        return 'Undefined'
Undefined = UndefinedType()


def schemaclass(*args, init_func=True, docstring=True, property_map=True):
    """A decorator to add boilerplate to a schema class

    This will read the _json_schema attribute of a SchemaBase class, and add
    one or all of three attributes/methods, based on the schema:

    - An __init__ function
    - a __doc__ docstring
    - an _valid_attr_map that maps property names to valid Python identifiers

    In all cases, if the attribute/method is explicitly defined in the class
    it will not be overwritten.

    A simple invocation adds all three attributes/methods:

        @schemaclass
        class MySchema(SchemaBase):
            _json_schema = {...}

    Optionally, you can invoke schemaclass with arguments to turn off
    some of the added behaviors:

        @schemaclass(init_func=True, docstring=False, property_map=True)
        class MySchema(SchemaBase):
            _json_schema = {...}
    """
    def _decorator(cls, init_func=init_func, docstring=docstring,
                   property_map=property_map):
        schema = SchemaInfo(getattr(cls, '_json_schema', {}))

        if init_func and '__init__' not in cls.__dict__:
            schema = SchemaInfo(getattr(cls, '_json_schema', {}))
            name = cls.__name__

            init_code = schema.init_code(name)
            globals_ = {name: cls, 'Undefined': Undefined}
            locals_ = {}
            exec(init_code, globals_, locals_)
            setattr(cls, '__init__', locals_['__init__'])

        if property_map and '_valid_attr_map' not in cls.__dict__:
            schema = SchemaInfo(getattr(cls, '_json_schema', {}))
            setattr(cls, '_valid_attr_map', schema.property_name_map())
            return cls

        if docstring and '__doc__' not in cls.__dict__:
            setattr(cls, '__doc__', schema.docstring(name))
    if len(args) == 0:
        return _decorator
    elif len(args) == 1:
        return _decorator(args[0])
    else:
        raise ValueError("optional arguments to schemaclass must be "
                         "passed by keyword")


class SchemaBase(object):
    """Base class for schema wrappers.

    Each derived class should set the _json_schema class attribute which is
    used for validation. If not specified in the class definition, an
    appropriate __init__ function will be generated by SchemaBaseMeta.
    """
    _simple_schema_value = Undefined
    _json_schema = {}
    _valid_attr_map = {}
    _attr_names_to_ignore = ('_json_schema', '_valid_attr_map',
                             '_simple_schema_value', '_attr_names_to_ignore')

    # TODO: use getattr/getattribute & setattr to access properties? This may
    #       be cleaner overall than the _attr_names_to_ignore approach, but
    #       requires a bit of finesse (i.e. using object.__getattribute__ to
    #       prevent infinite recursion when looking up non-property members).
    #       Issue with the current approach is that if someone has a json schema
    #       with a property that is among the above names, this will silently
    #       ignore it.

    def __init__(self, *args, **kwds):
        # Two valid options for initialization, which should be handled by
        # derived classes:
        # - a single arg with no kwds, for, e.g. {'type': 'string'}
        # - zero args with zero or more kwds for {'type': 'object'}
        if len(args) == 1 and len(kwds) == 0:
            self._simple_schema_value = args[0]
        elif len(args) == 0:
            for key, val in kwds.items():
                setattr(self, key, val)
        else:
            raise ValueError("Multiple arguments must be passed by keyword")

    def __repr__(self):
        val = self._simple_schema_value
        dct = self.__attr_dict()
        if dct:
            args = ("{0}={1}".format(key, repr(val))
                    for key, val in dct.items()
                    if val is not Undefined)
            args = '\n' + ',\n'.join(args)
            args = args.replace('\n', '\n  ')
            return "{0}({1}\n)".format(self.__class__.__name__, args)
        else:
            return "{0}({1})".format(self.__class__.__name__, val)

    @classmethod
    def _json_schema_hash(cls):
        """Return a unique hash of this class' _json_schema"""
        return hash_schema(cls._json_schema)

    def __attrs(self):
        """Return a list of instance attributes"""
        members = inspect.getmembers(self, lambda a: not inspect.isroutine(a))
        return [name for name, val in members
                if not (name.startswith('__') and name.endswith('__'))
                and name not in self._attr_names_to_ignore]

    def __attr_dict(self):
        """return a dicitionary of attributes to values"""
        return {attr: getattr(self, attr) for attr in self.__attrs()}

    def to_dict(self, validate=True):
        """Return a dictionary representation of the object

        Parameters
        ----------
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.

        Returns
        -------
        dct : dictionary
            The dictionary representation of this object

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and the dict does not conform to the schema
        """
        rmap_ = {val: key for key, val in self._valid_attr_map.items()}

        def _todict(val):
            if isinstance(val, SchemaBase):
                # only validate at the top level
                return val.to_dict(validate=False)
            else:
                return val

        dct = {rmap_.get(attr, attr): _todict(v)
               for attr, v in self.__attr_dict().items()
               if v is not Undefined}
        val = self._simple_schema_value

        if val is not Undefined and len(dct) > 0:
            raise ValueError("{0} instance has both a value and properties : "
                             "cannot serialize to dict")

        if val is Undefined:
            result = dct
        elif type(val) is dict:
            result = {attr: _todict(v) for attr, v in val.items()}
        elif type(val) is list:
            result = [_todict(v) for v in val]
        else:
            result = val
        if validate:
            jsonschema.validate(result, self._json_schema)
        return result

    @classmethod
    def from_dict(cls, dct, validate=True):
        """Construct class from a dictionary representation

        Parameters
        ----------
        dct : dictionary
            The dict from which to construct the class
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.

        Returns
        -------
        obj : Schema object
            The wrapped schema

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and dct does not conform to the schema
        """
        converter = FromDict(SchemaBase.__subclasses__())
        return converter.from_dict(cls, dct, validate=validate)
