import json
import jsonschema
import inspect
from collections import defaultdict

import six

Undefined = object()


def hash_schema(schema, use_json=True,
                exclude_keys=['definitions', 'description', '$schema']):
    """
    Compute a python hash for a nested dictionary which
    properly handles dicts, lists, sets, and tuples.

    At the top level, the function excludes from the hashed schema all keys
    listed in `exclude_keys`.

    This implements two methods: one based on conversion to JSON, and one based
    on recursive conversions of unhashable to hashable types.
    """
    if exclude_keys:
        schema = {key: val for key, val in schema.items()
                  if key not in exclude_keys}
    if use_json:
        s = json.dumps(schema, sort_keys=True)
        return hash(s)
    else:
        def _freeze(val):
            if isinstance(val, dict):
                return frozenset((k, _freeze(v)) for k, v in val.items())
            elif isinstance(val, set):
                return frozenset(map(_freeze, val))
            elif isinstance(val, list) or isinstance(val, tuple):
                return tuple(map(_freeze, val))
            else:
                return val
        return hash(_freeze(schema))


class SchemaHashRegistry(type):
    """
    A metaclass for SchemaBase which does one thing: every derived class will
    be added to a _schema_registry dict, with a key generated by the
    _json_schema_hash() class method. The goal is that given any schema, one
    can quickly locate any previously defined class that wraps that schema.
    This is required for the ``from_dict`` functionality in SchemaBase.
    """
    def __init__(cls, name, bases, dct):
        if not hasattr(cls, '_schema_registry'):
            # this is the base class.  Initialize the registry
            cls._schema_registry = defaultdict(list)
        else:
            # this is a derived class.  Add cls to the registry
            cls._schema_registry[cls._json_schema_hash()].append(cls)
        super(SchemaHashRegistry, cls).__init__(name, bases, dct)


@six.add_metaclass(SchemaHashRegistry)
class SchemaBase(object):
    _json_schema = {}
    _attr_names_to_ignore = ('_attr_names_to_ignore', '_json_schema', '_schema_registry')

    def __init__(self, **kwds):
        for key, val in kwds.items():
            setattr(self, key, val)

    @classmethod
    def _json_schema_hash(cls):
        """Return a unique hash of this class' _json_schema"""
        return hash_schema(cls._json_schema)

    def __attrs(self):
        """Return a list of instance attributes"""
        members = inspect.getmembers(self, lambda a: (not inspect.isroutine(a)))
        return [name for name, val in members
                if not (name.startswith('__') and name.endswith('__'))
                and name not in self._attr_names_to_ignore]

    def __attr_dict(self):
        """return a dicitionary of attributes to values"""
        return {attr: getattr(self, attr) for attr in self.__attrs()}

    def to_dict(self, validate=True):
        """return a dictionary representation of the object"""
        dct = {attr: (val.to_dict(validate=validate)
                      if isinstance(val, SchemaBase) else val)
               for attr, val in self.__attr_dict().items()
               if val is not Undefined}
        if validate:
            jsonschema.validate(dct, self._json_schema)
        return dct

    @classmethod
    def from_dict(cls, dct, validate=True):
        # TODO: implement additionalProperties & patternProperties
        if validate:
            jsonschema.validate(dct, cls._json_schema)
        props = cls._json_schema.get('properties', {})
        hashes = {prop: hash_schema(val) for prop, val in props.items()}
        wrappers = {prop: cls._schema_registry[hash_][0]
                    for prop, hash_ in hashes.items()
                    if hash_ in cls._schema_registry}
        dct = {key: wrappers[key].from_dict(val) if key in wrappers else val
               for key, val in dct.items()}
        return cls(**dct)
