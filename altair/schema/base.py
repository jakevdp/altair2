import collections
import inspect
import json
import keyword
import re

import jsonschema
import six

from .utils import hash_schema, SchemaInfo, resolve_references


class UndefinedType(object):
    """A singleton object for marking undefined attributes"""
    __instance = None
    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.__instance, cls):
            cls.__instance = object.__new__(cls, *args, **kwargs)
        return cls.__instance
    def __repr__(self):
        return 'Undefined'
Undefined = UndefinedType()


class SchemaBaseMeta(type):
    """
    A metaclass for SchemaBase. The assumption is that each subclass of SchemaBase
    will be defined by its _json_schema attribute, which is a dict containing a
    valid JSON schema, and governs the way the class behaves.

    SchemaBaseMeta does two things:

    - if the class does not explicitly define an __init__() function, then
      define an appropriate __init__ function based on its _json_schema.

    - create a _schema_registry dict in the base class, and add each subclass
      to it, indexed by a unique hash computed from its _json_schema. This
      part is essential for the ``from_dict`` constructor, because it allows
      the constructor to quickly create an appropriate class hierarchy without
      having to hard-code all possibilities in the class definition.

    If you're unfamiliar with metaclasses, I have just the blog post for you:
    https://jakevdp.github.io/blog/2012/12/01/a-primer-on-python-metaclasses/
    """
    def __init__(cls, name, bases, dct):
        schema = SchemaInfo(dct.get('_json_schema', {}))

        # If it's not provided, add an _valid_attr_map mapping to map invalid
        # property names to valid python attribute names
        if '_valid_attr_map' not in dct:
            setattr(cls, '_valid_attr_map', schema.property_name_map())

        # Add a docstring if not specified
        if '__doc__' not in dct:
            setattr(cls, '__doc__', schema.docstring(name))

        # Add init function if not defined explicitly in the class
        if '__init__' not in dct:
            init_code = schema.init_code(name)
            # Because of the super() call, we need cls to be in global scope
            globals_ = {name: cls, 'Undefined': Undefined}
            exec(init_code, globals_, dct)
            # The result of the executed function definition is in dct
            setattr(cls, '__init__', dct['__init__'])

        # Add this class to the registry
        if not hasattr(cls, '_schema_registry'):
            # this is the base class.  Initialize the registry
            cls._schema_registry = collections.defaultdict(list)
        else:
            # this is a derived class.  Add cls to the registry
            cls._schema_registry[cls._json_schema_hash()].append(cls)
        super(SchemaBaseMeta, cls).__init__(name, bases, dct)


@six.add_metaclass(SchemaBaseMeta)
class SchemaBase(object):
    """Base class for schema wrappers.

    Each derived class should set the _json_schema class attribute which is
    used for validation. If not specified in the class definition, an
    appropriate __init__ function will be generated by SchemaBaseMeta.
    """
    _simple_schema_value = Undefined
    _json_schema = {}
    _valid_attr_map = {}
    _attr_names_to_ignore = ('_json_schema', '_valid_attr_map',
                             '_schema_registry', '_simple_schema_value',
                             '_attr_names_to_ignore')

    # TODO: use getattr/getattribute & setattr to access properties? This may
    #       be cleaner overall than the _attr_names_to_ignore approach, but
    #       requires a bit of finesse (i.e. using object.__getattribute__ to
    #       prevent infinite recursion when looking up non-property members).
    #       Issue with the current approach is that if someone has a json schema
    #       with a property that is among the above names, this will silently
    #       ignore it.

    def __init__(self, *args, **kwds):
        # Two valid options for initialization, which should be handled by
        # derived classes:
        # - a single arg with no kwds, for, e.g. {'type': 'string'}
        # - zero args with zero or more kwds for {'type': 'object'}
        if len(args) == 1 and len(kwds) == 0:
            self._simple_schema_value = args[0]
        elif len(args) == 0:
            for key, val in kwds.items():
                setattr(self, key, val)
        else:
            raise ValueError("Multiple arguments must be passed by keyword")

    @classmethod
    def _json_schema_hash(cls):
        """Return a unique hash of this class' _json_schema"""
        return hash_schema(cls._json_schema)

    def __attrs(self):
        """Return a list of instance attributes"""
        members = inspect.getmembers(self, lambda a: not inspect.isroutine(a))
        return [name for name, val in members
                if not (name.startswith('__') and name.endswith('__'))
                and name not in self._attr_names_to_ignore]

    def __attr_dict(self):
        """return a dicitionary of attributes to values"""
        return {attr: getattr(self, attr) for attr in self.__attrs()}

    def to_dict(self, validate=True):
        """Return a dictionary representation of the object

        Parameters
        ----------
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.

        Returns
        -------
        dct : dictionary
            The dictionary representation of this object

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and the dict does not conform to the schema
        """
        rmap_ = {val: key for key, val in self._valid_attr_map.items()}

        def _todict(val):
            if isinstance(val, SchemaBase):
                # only validate at the top level
                return val.to_dict(validate=False)
            else:
                return val

        dct = {rmap_.get(attr, attr): _todict(v)
               for attr, v in self.__attr_dict().items()
               if v is not Undefined}
        val = self._simple_schema_value

        if val is not Undefined and len(dct) > 0:
            raise ValueError("{0} instance has both a value and properties : "
                             "cannot serialize to dict")

        if val is Undefined:
            result = dct
        elif type(val) is dict:
            result = {attr: _todict(v) for attr, v in val.items()}
        elif type(val) is list:
            result = [_todict(v) for v in val]
        else:
            result = val
        if validate:
            jsonschema.validate(result, self._json_schema)
        return result

    @classmethod
    def _from_dict_union(cls, dct, validate=False):
        """from_dict for an anyOf or oneOf object"""
        schema = resolve_references(cls._json_schema)
        schemas = schema.get('anyOf', []) + schema.get('oneOf', [])
        for schema in schemas:
            matches = cls._schema_registry[hash_schema(schema)]
            if not matches:
                continue
            try:
                obj = matches[-1].from_dict(dct, validate=validate)
            except TypeError:
                continue
            except jsonschema.ValidationError:
                continue
            else:
                return obj
        return None

    @classmethod
    def _from_dict_object(cls, dct, validate=False):
        schema = resolve_references(cls._json_schema)
        map_ = cls._valid_attr_map
        props = schema.get('properties', {})
        hashes = {prop: hash_schema(val) for prop, val in props.items()}
        matches = {prop: cls._schema_registry[hash_]
                   for prop, hash_ in hashes.items()}
        # TODO: do something more than simply selecting the last match?
        wrappers = {prop: match[-1] for prop, match in matches.items() if match}
        kwds = {map_.get(key, key): (wrappers[key].from_dict(val, validate=validate)
                                     if key in wrappers else val)
                for key, val in dct.items()}
        return cls(**kwds)

    @classmethod
    def _from_dict_list(cls, dct, validate=False):
        # TODO: find wrapper class for elements in items
        return cls(dct)

    @classmethod
    def from_dict(cls, dct, validate=True):
        """Construct class from a dictionary representation

        Parameters
        ----------
        dct : dictionary
            The dict from which to construct the class
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.

        Returns
        -------
        obj : Schema object
            The wrapped schema

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and dct does not conform to the schema
        """
        # TODO: implement additionalProperties & patternProperties
        if validate:
            jsonschema.validate(dct, cls._json_schema)

        schema = resolve_references(cls._json_schema)

        if 'anyOf' in schema or 'oneOf' in schema:
            obj = cls._from_dict_union(dct, validate=False)
            if obj is not None:
                return obj

        if isinstance(dct, dict):
            return cls._from_dict_object(dct, validate=False)
        elif isinstance(dct, list):
            return cls._from_dict_list(dct, validate=False)
        else:
            return cls(dct)
