import collections
import json

import jsonschema

from .utils import resolve_references


class UndefinedType(object):
    """A singleton object for marking undefined attributes"""
    __instance = None
    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.__instance, cls):
            cls.__instance = object.__new__(cls, *args, **kwargs)
        return cls.__instance
    def __repr__(self):
        return 'Undefined'
Undefined = UndefinedType()


class SchemaBase(object):
    """Base class for schema wrappers.

    Each derived class should set the _json_schema class attribute which is
    used for validation. If not specified in the class definition, an
    appropriate __init__ function will be generated by SchemaBaseMeta.
    """
    _schema = {}
    _rootschema = None

    def __init__(self, *args, **kwds):
        # Two valid options for initialization, which should be handled by
        # derived classes:
        # - a single arg with no kwds, for, e.g. {'type': 'string'}
        # - zero args with zero or more kwds for {'type': 'object'}
        assert len(args) == (0 if kwds else 1)

        # use object.__setattr__ because we override setattr below.
        object.__setattr__(self, '_args', args)
        object.__setattr__(self, '_kwds', kwds)

    def __getattr__(self, item):
        # reminder: getattr is called after the normal lookups
        return self._kwds[item]

    def __setattr__(self, item , val):
        self._kwds[item] = val

    def __getitem__(self, item):
        return self._kwds[item]

    def __setitem__(self, item, val):
        self._kwds[item] = val

    def __repr__(self):
        if self._kwds:
            args = ("{0}: {1!r}".format(key, val)
                    for key, val in self._kwds.items()
                    if val is not Undefined)
            args = '\n' + ',\n'.join(args)
            return "<{0} {{{1}\n}}>".format(self.__class__.__name__,
                                            args.replace('\n', '\n  '))
        else:
            return "<{0}({1})>".format(self.__class__.__name__, self._args[0])

    def to_dict(self, validate=True, ignore=[], context={}):
        """Return a dictionary representation of the object

        Parameters
        ----------
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.
        ignore : list
            A list of keys to ignore. This will *not* passed to child to_dict
            function calls.
        context : dict (optional)
            A context dictionary that will be passed to all child to_dict
            function calls

        Returns
        -------
        dct : dictionary
            The dictionary representation of this object

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and the dict does not conform to the schema
        """
        def _todict(val):
            if isinstance(val, SchemaBase):
                # only validate at the top level
                return val.to_dict(validate=False, context=context)
            elif isinstance(val, list):
                return [_todict(v) for v in val]
            elif isinstance(val, dict):
                return {k: _todict(v) for k, v in val.items()
                        if v is not Undefined}
            else:
                return val

        if self._args and not self._kwds:
            result = _todict(self._args[0])
        elif self._kwds and not self._args:
            result = _todict({k: v for k, v in self._kwds.items()
                              if k not in ignore})
        else:
            raise ValueError("{0} instance has both a value and properties : "
                             "cannot serialize to dict")
        if validate:
            self.validate(result)
        return result

    @classmethod
    def from_dict(cls, dct, validate=True):
        """Construct class from a dictionary representation

        Parameters
        ----------
        dct : dictionary
            The dict from which to construct the class
        validate : boolean
            If True (default), then validate the output dictionary
            against the schema.

        Returns
        -------
        obj : Schema object
            The wrapped schema

        Raises
        ------
        jsonschema.ValidationError :
            if validate=True and dct does not conform to the schema
        """
        converter = _FromDict(SchemaBase.__subclasses__())
        return converter.from_dict(cls, self._schema, dct, validate=validate)

    @classmethod
    def validate(cls, instance):
        """
        Validate the instance against the class schema in the context of the
        roootschema.
        """
        resolver = jsonschema.RefResolver.from_schema(cls._rootschema or cls._schema)
        return jsonschema.validate(instance, cls._schema, resolver=resolver)

    @classmethod
    def resolve_references(cls, schema):
        """Resolve references of the schema the context of this object's schema"""
        resolver = jsonschema.RefResolver.from_schema(cls._rootschema
                                                      or cls._schema
                                                      or schema)
        while '$ref' in schema:
            ref, schema = resolver.resolve(schema['$ref'])
        return schema


class _FromDict(object):
    """Class used to construct SchemaBase class hierarchies from a dict

    The primary purpose of using this class is to be able to build a hash table
    that maps schemas to their wrapper classes. The candidate classes are
    specified in the ``class_list`` argument to the constructor.
    """
    _hash_exclude_keys = ('definitions', 'title', 'description', '$schema', 'id')

    def __init__(self, class_list):
        # Create a mapping of a schema hash to a list of matching classes
        # This lets us quickly determine the correct class to construct
        self.class_dict = collections.defaultdict(list)
        for cls in class_list:
            self.class_dict[self.hash_schema(self._get_schema(cls))].append(cls)

    @classmethod
    def hash_schema(cls, schema, use_json=True):
        """
        Compute a python hash for a nested dictionary which
        properly handles dicts, lists, sets, and tuples.

        At the top level, the function excludes from the hashed schema all keys
        listed in `exclude_keys`.

        This implements two methods: one based on conversion to JSON, and one based
        on recursive conversions of unhashable to hashable types; the former seems
        to be slightly faster in several benchmarks.
        """
        if cls._hash_exclude_keys:
            schema = {key: val for key, val in schema.items()
                      if key not in cls._hash_exclude_keys}
        if use_json:
            s = json.dumps(schema, sort_keys=True)
            return hash(s)
        else:
            def _freeze(val):
                if isinstance(val, dict):
                    return frozenset((k, _freeze(v)) for k, v in val.items())
                elif isinstance(val, set):
                    return frozenset(map(_freeze, val))
                elif isinstance(val, list) or isinstance(val, tuple):
                    return tuple(map(_freeze, val))
                else:
                    return val
            return hash(_freeze(schema))

    def _get_schema(self, cls, resolve_refs=False):
        # "private" variable name mangling
        schema = getattr(cls, '_{0}__schema'.format(cls.__name__), {})
        if resolve_refs:
            schema = resolve_references(schema)
        return schema

    def from_dict(self, constructor, schema, dct, validate=True):
        # TODO: introspect lists, objects, etc. when they don't have a wrapper.
        #       could do this by passing the schema rather than cls.
        if validate:
            jsonschema.validate(dct, schema)
        schema = resolve_references(schema)

        def get_wrapper(schema):
            # TODO: do something more than simply selecting the last match?
            hash_ = self.hash_schema(schema)
            matches = self.class_dict[hash_]
            if not matches:
                return lambda x: x
            else:
                return matches[-1]

        if 'anyOf' in schema or 'oneOf' in schema:
            schemas = schema.get('anyOf', []) + schema.get('oneOf', [])
            for schema in schemas:
                wrapper = get_wrapper(schema)
                try:
                    return self.from_dict(wrapper, schema, dct, validate=True)
                except TypeError:
                    continue
                except jsonschema.ValidationError:
                    continue

        if isinstance(dct, dict):
            # TODO: handle schemas for additionalProperties/patternProperties
            props = schema.get('properties', {})
            wrappers = {prop: get_wrapper(val)
                        for prop, val in props.items()}
            print(props)
            print(wrappers)
            kwds = {key: (self.from_dict(wrappers[key], props[key], val, validate=False)
                          if key in wrappers else val)
                    for key, val in dct.items()}
            return constructor(**kwds)
        elif isinstance(dct, list):
            if 'items' in schema:
                itemschema = schema['items']
                wrapper = get_wrapper(schema['items'])
            else:
                itemschema = {}
                wrapper = lambda x: x
            return constructor([self.from_dict(wrapper, itemschema, val, validate=False)
                                for val in dct])
        else:
            return constructor(dct)
